<html>
<!DOCTYPE html>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>高性能Mysql笔记五</title>
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="stylesheet" href="../css/bootstrap.min.css">
	<link rel="stylesheet" href="../css/font-awesome.min.css">
    <link rel="stylesheet" href="../plugins/ckeditor/plugins/codesnippet/lib/highlight/styles/googlecode.css">
    <link rel="stylesheet" type="text/css" href="../css/front/screen.css">
    <script src="../plugins/ckeditor/plugins/codesnippet/lib/highlight/highlight.pack.js"></script>
	<style type="text/css">
		.list{
			margin-top:5em;
			position: fixed;
		}
		
		.list h4{
			padding-bottom:0.5em;
			border-bottom:2px solid lightgray;
		}
		
		.list .readTitle li{
			margin-top:0.4em;
			padding-left:1em;
			border:2px solid white;
		}
		.list .readTitle li:hover{
			border-left:2px solid black;
			color:blue;
		}
		.liHover{
			border-left:2px solid black !important;
		}
		.aHover{
			color:blue;
		}
		.list .readTitle li a:hover{
			color:blue;
			text-decoration: none;
		}
	</style>
</head>
<body>
    <section class="content-wrap container-fluid">
        <div class="container">
            <div class="row">
				<div class="col-md-3 visible-lg-block visible-md-block">
					<div class="list">
						<h4>阅读目录</h4>
						<div>
							<ul class="readTitle list-unstyled"></ul>
						</div>
					</div>
				</div>
                 <main class="col-md-19 main-content">
					<article class="post row">
					<header class="post-head">
				        <h1 class="post-title">高性能Mysql笔记五</h1>
				        <section class="post-meta">
					        <span><span class="glyphicon glyphicon-user"></span>:<span>c</span></span>|
				            <span><span class="glyphicon glyphicon-bookmark"></span>:<span>Database</span></span>|
				            <span><span class="glyphicon glyphicon-time"></span>:<span>2018-09-01</span></span>
				        </section>
				    </header>
				    <section class="post-content"><h2>分区表</h2>

<pre>
<code>分区表是一种粗粒度的、简易的索引策略，适用于大数据量的过滤场景。最适合的场景是，在没有合适的索引时，对其中几个分区进行全表扫描，或者是只有一个分区和索引是热点，而且这个分区和索引能够都在内存中；限制单表分区数不要超过150个，并且注意某些导致无法做分区过滤的细节，分区表对于单条记录的查询并没有什么优势，需要注意这类查询的性能。

分区的场景
1、表非常大以至于无法全部都放在内存中，或者只在表的最后部分有热点数据，其他均是历史数据
2、分区表的数据更容易维护。例如，可以通过清除整个分区的方式来批量删除大量数据。还可以对一个独立分区进行优化、检查、修复等操作
3、分区表的数据可以分布在不同的物理设备上，从而高效地利用多个硬件设备
4、可以使用分区表来避免某些特殊的瓶颈，例如InnoDB的单个索引的互斥访问、ext3文件系统的inode锁竞争等
5、如果需要，还可以备份和恢复独立的分区，这在非常大的数据集的场景下效果非常好

分区表限制
1、一个表最多只能有1024个分区。
2、分区表达式必须是整数、返回整数的表达式或者直接使用列（5.5新特性）来进行分区。
3、如果分区字段中有主键或者唯一索引的列，那么所有主键列和唯一索引列都必须包含进来。
4、分区表中无法使用外键约束。
5、所有分区都必须使用相同的存储引擎。
6、分区函数中可以使用的函数和表达式也有一些限制。
7、某些存储引擎不支持分区。
8、对于MyISAM的分区表，不能再使用LOAD INDEX INTO CACHE操作。
9、对于MyISAM表，使用分区表时需要打开更多的文件描述符。虽然看起来是一个表，其实背后有很多独立的分区，每一个分区对于存储引擎来说都是一个独立的表。这样即使分区表只占用一个表缓存条目，文件描述符还是需要多个。因此，即使已经配置了合适的表缓存，以确保不会超过操作系统的单个进程可以打开的文件描述符的个数，但对于分区表而言，还是会出现超过文件描述符限制的问题。

分区表上的操作逻辑
SELECT查询
当查询一个分区表的时候，分区层先打开并锁住所有的底层表，优化器判断是否可以过滤部分分区，然后再调用对应的存储引擎接口访问各个分区的数据，查询时只能根据列而不能是表达式来过滤分区。
INSERT操作
当写入一条记录时，分区层先打开并锁住所有的底层表，然后确定哪个分区接收这条记录，再将记录写入对应底层表
DELETE操作
当删除一条记录时，分区层先打开并锁住所有的底层表，然后确定数据对应的分区，最后对相应底层表进行删除操作
UPDATE操作
当更新一条记录时，分区层先打开并锁住所有的底层表，MySQL先确定需要更新的记录在哪个分区，然后取出数据并更新，再判断更新后的数据应该放在哪个分区，最后对底层表进行写入操作，并对原数据所在的底层表进行删除操作
（注：“先打开并锁住所有的底层表”并不是说分区表在处理过程中是锁住全表的。如果存储引擎能够自己实现行级锁，如InnoDB，则会在分区层释放对应表锁）

分区表的类型
RNAGE分区：每个分区存储落在某个范围的记录，分区表达式可以是列，也可以是包含列的表达式,常用
eg:按年进行分区
PARTITION BY RANGE(c_data) (
PARTITION p01 VALUES LESS THAN('2010-01-01'),
PARTITION p02 VALUES LESS THAN('2015-01-01'),
PARTITION pother VALUES LESS THAN MAXVALUE);
LIST分区：基于列值匹配一个离散值集合中的某个值来进行选择，分区表达式可以是列，也可以是包含列的表达式
eg:按方位进行分区
PARTITION BY LIST COLUMNS (category) (
PARTITION p01 VALUES IN ( 'tomato', 'potato'),
PARTITION p02 VALUES IN ( 'banana', 'apple')
);
HASH分区:基于给定的分区个数，将数据分配到不同的分区，分区表达式可以是列，也可以是包含列的表达式，分布情况不可控,PARTITIONS为分区个数
eg:按年进行分区
PARTITION BY HASH(YEAR(c_data))
PARTITIONS 6;
LINEAR HASH：与HASH分区的区别在于，LINEAR HASH功能使用一个线性的2的幂运算法则，而HASH分区使用的是求哈希函数值的模数
eg:按年进行分区
PARTITION BY LINEAR HASH(YEAR(c_data))
PARTITIONS 6;
KSY分区：类似于按HASH分区，区别在于KEY分区只支持计算一列或多列

分区表容易出现的问题
1、如果分区表达式的值为NULL或其他非法值，记录会存放到第一个分区，导致第一分区非常庞大，而查询除了对应的分区外还要额外查询第一分区（防止漏数据），代价会非常大。解决：创建一个“无用的第一分区”
2、定义的索引列和分区列不匹配，会导致查询无法进行分区过滤。即因为每个分区都有其独立的索引，因此扫描字段的索引就需要扫描每一个分区内对应的索引。如果每个分区内对应索引的非叶子节点都在内存中，扫描的速度还可以接受，但如果能跳过某些分区索引会更好，应该避免建立和分区列不匹配的索引或者查询中包含了可以过滤分区的条件
3、范围分区对于选择分区的成本很高，因为服务器需要扫描所有的范围条件来确定分区，随着分区数的增长，成本会越来越高（写入大量数据，每写入一行数据到范围分区的表时，都需要扫描分区定义列表来找到合适的目标分区）。可以通过限制分区的数量来缓解此问题，一般建议100个左右的分区，其他的分区类型，比如键分区和哈希分区，则没有这样的问题。
4、打开并锁住所有底层表的成本可能很高，当查询访问分区表的时候，MySQL需要打开并锁住所有的底层表，这是分区表的另一个开销。这个操作在分区过滤之前发生，所以无法通过分区过滤降低此开销，并且该开销也和分区类型无关，会影响所有的查询。这一点对一些本身操作非常快的查询，比如主键查询，会带来明显的额外开销。可以用批量操作的方式来降低单个操作的开销，例如使用批量插入或者LOAD DATA INFILE、一次删除多行数据等等。当然同时还是需要限制分区的个数
5、维护分区的成本可能很高，某些分区维护操作的速度会非常快，例如新增或者删除分区。而有些操作，例如重组分区或者类似ALTER语句的操作：这类操作需要复制数据。重组分区的原理与ALTER类似，先创建一个临时的分区，然后将数据复制到其中，最后再删除原分区</code></pre>

<h2>视图</h2>

<pre>
<code>视图本身是一个虚拟表，不存放任何数据。在使用SQL语句访问视图的时候，它返回的数据是MySQL从其他表中生成的。视图和表是在同一个命名空间，MySQL在很多地方对于视图和表是同样对待的。不过视图和表也有不同，例如，不能对视图创建触发器，也不能使用DROP TABLE命令删除视图。

对好几个表的复杂查询，使用视图有时候会大大简化问题。当视图使用临时表时，无法将WHERE条件下推到各个具体的表，也不能使用任何索引，需要特别注意这类查询的性能。如果为了便利，使用视图是很合适的。

算法
合并算法: 将存放的视图sql和用户发起的查询sql合并后执行，推荐
临时表算法: 由存放的视图sql先创建临时表后根据用户的查询sql查询返回

可更新视图
可以通过更新视图更新相关表, 所有临时表算法实现的视图都无法更新

视图对性能的影响
一般情况视图不能提升性能,在某些情况下可以帮助提升性能,需要做比较详细的测试
视图还可以实现基于列的权限控制不用真正创建列权限

视图的限制
不保存视图定义的原始sql语句
查看视图创建的语句,可以通过使用视图的.frm文件的最后一行获取一些信息</code></pre>

<h2>外键约束</h2>

<pre>
<code>外键限制会将约束放到MySQL中，这对于必须维护外键的场景，性能会更高。不过这也会带来额外的复杂性和额外的索引消耗，还会增加多表之间的交互，会导致系统中更多的锁和竞争。外键可以被看作是一个确保系统完整性的额外的特性，但是如果设计的是一个高性能的系统，那么外键就显得很臃肿了。很多人在更在意系统的性能的时候都不会使用外键，而是通过应用程序来维护

InnoDB强制外键使用索引。如果外键列的选择性很低，则会导致一个非常大且选择性很低的索引。
查询需要额外访问一些表,需要额外的锁容易导致额外的锁等待甚至死锁
如果外键单纯做约束,通常在应用程序里实现会更好</code></pre>

<h2>在MySQL内部存储代码</h2>

<pre>
<code>存储代码的优点
1、在服务器内部执行，离数据近，还可以节省带宽和网络延迟
2、代码重用。可以方便地统一业务规则，保证行为一致性，简化代码的维护和版本更新
3、帮助提升安全，比如提供更细粒度的权限控制。例如银行用于转移资金的存储过程：这个存储过程可以在一个事务中完成资金转移和记录用于审计的日志。应用程序也可以通过存储过程的接口访问那些没有权限的表
4、服务器端可以缓存存储过程的执行计划，大大降低反复调用存储过程的消耗
5、因为是在服务器端部署的，所以备份、维护都可以在服务器端完成。所以存储程序的维护工作很简单。没什么外部依赖，如任何Perl包和其他不想在服务器上部署的外部软件
6、它可以对应用开发和数据库开发人员之间进行更好地分工

存储代码的缺点
1、MySQL本身并未提供好用的开发和调试工具，较之应用程序的代码，存储代码效率要稍微差些，也很难实现太复杂的逻辑
3、提高部署难度，需要额外部署存储程序
4、安全隐患，因为存储程序部署在服务器内，如果将非标准的加密功能放在存储程序中，那么若数据库被攻破，数据同时也会泄漏
5、存储过程会给数据库服务器增加额外的压力，而数据库服务器的扩展性相比应用服务器要差很多
6、MySQL无法控制存储程序的资源消耗，所以在存储过程中的一个小错误，可能直接把服务器拖死
7、存储代码在MySQL中的实现也有很多限制——执行计划缓存是连接级别的，游标的物化和临时表相同，在MySQL 5.5版本之前，异常处理也非常困难，等等。简而言之，较之T-SQL或者PL/SQL，MySQL的存储代码功能还非常非常弱
8、调试MySQL的存储过程是一件很困难的事情。如果慢日志只是给出CALL XYZ('A')，通常很难定位到底是什么导致的问题，这时不得不看看存储过程中的SQL语句是如何编写的。（这在Percona Server中可以通过参数控制。）
9、它和基于语句的二进制日志复制合作得并不好。在基于语句的复制中，使用存储代码通常有很多的陷阱，除非你在这方面的经验非常丰富或者非常有耐心排查这类问题，否则需要谨慎使用

存储过程和函数
存储过程和函数的限制
1、优化器无法使用关键字DETERMINISTIC来优化单个查询中多次调用存储函数的情况
2、优化器无法评估存储函数的执行成本
3、每个连接都有独立的存储过程的执行计划缓存。如果有多个连接需要调用同一个存储过程，将会浪费缓存空间来反复缓存同样的执行计划。（如果使用的是连接池或者是持久化连接，那么执行计划缓存可能会有更长的生命周期。）
4、存储程序和复制是一组诡异组合。如果可以，最好不要复制对存储程序的调用。直接复制由存储程序改变的数据则会更好。MySQL 5.1引入的行复制能够改善这个问题。如果在MySQL 5.0中开启了二进制日志，那么要么在所有的存储过程中都增加DETERMINISTIC限制或者设置MySQL的选项log_bin_trust_function_creators。

触发器
触发器可以让你在执行INSERT、UPDATE或者DELETE的时候，指定执行前触发还是在执行后触发一些特定的操作。
触发器注意
1、对每一个表的每一个事件，最多只能定义一个触发器（换句话说，不能在AFTER INSERT上定义两个触发器）。
2、MySQL只支持“基于行的触发”，也就是说，触发器始终是针对一条记录的，而不是针对整个SQL语句的。如果变更的数据集非常大的话，效率会很低。
3、触发器可以掩盖服务器背后的工作（sql的触发器引起的大量操作）
4、触发器的问题很难排查，如果某个性能问题和触发器相关，会很难分析和定位
5、触发器可能导致死锁和锁等待
6、如果触发器失败，那么原来的SQL语句也会失败而导致服务器抛出的错误代码
7、操作MyISAM表的时候，如果遇到错误，没有办法做回滚操作，InnoDB表可以回滚

事件
1、类似于Linux的定时任务，不过是完全在MySQL内部实现的,可以在表INFORMATION_SCHEMA.EVENTS中看到各个事件状态。
2、事件在一个独立事件调度线程中被初始化，这个线程和处理连接的线程没有任何关系。它不接收任何参数，也没有任何的返回值
3、你可以指定事件本身是否被复制。有时需要被复制，有时则不需要
4、如果一个定时事件执行需要很长的时间，那么有可能会出现前面一个事件还未执行完成，下一个时间点的事件又开始了。MySQL本身不会防止这种并发，所以需要用户自己编写这种情况下的防并发代码。你可以使用函数GET_LOCK()来确保当前总是只有一个事件在被执行</code></pre>

<h2>游标</h2>

<pre>
<code>MySQL在服务器端提供只读的、单向的游标，而且只能在存储过程或者更底层的客户端API中使用。因为MySQL游标中指向的对象都是存储在临时表中而不是实际查询到的数据，所以MySQL游标总是只读的。它可以逐行指向查询结果，然后让程序做进一步的处理。在一个存储过程中，可以有多个游标，也可以在循环中“嵌套”地使用游标</code></pre>

<h2>绑定变量</h2>

<pre>
<code>当查询语句的解析和执行计划生成消耗了主要的时间，那么绑定变量可以在一定程度上解决问题。因为只需要解析一次，对于大量重复类型的查询语句，性能会有很大的提高。另外，执行计划的缓存和传输使用的二进制协议，这都使得绑定变量的方式比普通SQL语句执行的方式要更快。

创建一个绑定变量sql时客户端向服务器发送了一个sql语句原型，可以使用问号作为sql的占位,在使用sql接口执行时赋予变量值（INSERT INTO tbl(col1, col2, col3) VALUES (?, ?, ?);）
服务器端解析并存储这个sql语句的部分执行计划返回客户端一个sql语句处理句柄
通过向服务器端发送各个问号的取值和这个SQL的句柄来执行一个具体的查询

优势
1、在服务器端只需要解析一次SQL语句。
2、在服务器端某些优化器的工作只需要执行一次，因为它会缓存一部分的执行计划。
3、以二进制的方式只发送参数和句柄，比起每次都发送ASCII码文本效率更高，一个二进制的日期字段只需要三个字节，但如果是ASCII码则需要十个字节。不过最大的节省还是来自于BLOB和TEXT字段，绑定变量的形式可以分块传输，而无须一次性传输。二进制协议在客户端也可能节省很多内存，减少了网络开销，另外，还节省了将数据从存储原始格式转换成文本格式的开销。
4、仅仅是参数——而不是整个查询语句——需要发送到服务器端，所以网络开销会更小。
5、MySQL在存储参数的时候，直接将其存放到缓存中，不再需要在内存中多次复制。
6、绑定变量相对也更安全。无须在应用程序中处理转义，一则更简单了，二则也大大减少了SQL注入和攻击的风险

限制和注意事项
1、绑定变量是会话级别的，所以连接之间不能共用绑定变量句柄。同样地，一旦连接断开，则原来的句柄也不能再使用了。（连接池和持久化连接可以在一定程度上缓解这个问题。）
2、并不是所有的时候使用绑定变量都能获得更好的性能。如果只是执行一次SQL，那么使用绑定变量方式无疑比直接执行多了一次额外的准备阶段消耗，而且还需要一次额外的网络开销。（要正确地使用绑定变量，还需要在使用完成后，释放相关的资源。）
3、当前版本下，还不能在存储函数中使用绑定变量（但是存储过程中可以使用）。
4、如果总是忘记释放绑定变量资源，则在服务器端很容易发生资源“泄漏”。绑定变量 SQL总数的限制是一个全局限制，所以某一个地方的错误可能会对所有其他的线程都产生影响。
5、有些操作，如BEGIN，无法在绑定变量中完成。</code></pre>

<h2>用户自定义函数</h2>

<pre>
<code>用户自定义函数（UDF）
存储过程只能使用SQL来编写，而UDF没有这个限制，你可以使用支持C语言调用约定的任何编程语言来实现
UDF必须事先编译好并动态链接到服务器上，这种平台相关性使得UDF在很多方面都很强大。UDF速度非常快，而且可以访问大量操作系统的功能，还可以使用大量库函数
和使用SQL语言编写存储程序不同，UDF无法读写数据表——至少，无法在调用UDF的线程中使用当前事务处理的上下文来读写数据表。这意味着，它更适合用作计算或者与外面的世界交互</code></pre>

<h2>插件</h2>

<pre>
<code>存储过程插件
后台插件: 如Percona Server中包含的Handler-Socket
INFORMATION_SCHEMA插件
全文解析插件: 可以对文档进行分词处理
审计插件: 可以用作记录事件日志
认证插件: 扩展认证功能</code></pre>

<h2>字符集和校对</h2>

<pre>
<code>字符集：一种从二进制编码到某类字符符号的映射
校对：一组用于某个字符集的排序规则，格式：以其相关的字符集名开始，中间包括一个语言名，并且以_ci（大小写不敏感）、_cs（大小写敏感）或_bin（二元）结束
每种字符集都可能有多种校对规则，并且都有一个默认的校对规则。每个校对规则都只针对某个特定的字符集

创建数据库的时候，默认字符集为服务器上的character_set_server的字符集。创建表的时候，默认字符集为数据库的字符集。创建列的时候，默认字符集为表的字符集。但真正存放数据的是列，只有当列没有指定字符集的时候，列数据才会使用表的字符集进行存储

服务器和客户端通信
当服务器和客户端通信的时候，它们可能使用不同的字符集。这时，服务器端将进行必要的翻译转换工作：
1、服务器端总是假设客户端是按照character_set_client设置的字符来传输数据和SQL语句的。
2、当服务器收到客户端的SQL语句时，它先将其转换成字符集character_set_connection。它还使用这个设置来决定如何将数据转换成字符串。
3、当服务器端返回数据或者错误信息给客户端时，它会将其转换成character_set_result。
根据需要，可以使用SET NAMES或者SET CHARACTER SET语句来改变上面的设置。不过在服务器上使用这个命令只能改变服务器端的设置。客户端程序和客户端的API也需要使用正确的字符集才能避免在通信时出现问题

选择字符集和校对规则
字符集：一个数据库中使用统一字符集，否则容易造成字符集之间的不兼容问题。
校对规则：_ci（以大小写不敏感来比较大小）、_cs（以大小写敏感来比较大小）或_bin（以字符串编码的二进制值来比较大小）</code></pre>

<h2>全文索引</h2>

<h2>分布式（XA）事务</h2>

<pre>
<code>很少有人用MySQL的XA事务特性。除非你真正明白参数innodb_support_xa的意义，否则不要修改这个参数的值，并不是只有显式使用XA事务时才需要设置这个参数。InnoDB和二进制日志也是需要使用XA事务来做协调的，从而确保在系统崩溃的时候，数据能够一致地恢复。</code></pre>

<h2>查询缓存</h2>

<pre>
<code>完全相同的查询在重复执行的时候，查询缓存可以立即返回结果，而无须在数据库中重新执行一次。根据我们的经验，在高并发压力环境中查询缓存会导致系统性能的下降，甚至僵死。如果你一定要使用查询缓存，那么不要设置太大内存，而且只有在明确收益的时候才使用。那该如何判断是否应该使用查询缓存呢？建议使用Percona Server，观察更细致的日志，并做一些简单的计算。还可以查看缓存命中率（并不总是有用）、“INSERTS和SELECT比率”（这个参数也并不直观）、或者“命中和写入比率”（这个参考意义较大）。查询缓存是一个非常方便的缓存，对应用程序完全透明，无须任何额外的编码，但是，如果希望有更高的缓存效率，我们建议使用memcached或者其他类似的解决方案

MySQL查询缓存保存查询返回的完整结果。当查询命中该缓存，MySQL会立刻返回结果，跳过了解析、优化和执行阶段。

当查询语句中有一些不确定的数据时，则不会被缓存。例如函数NOW()或者CURRENT_USER等
当查询语句中有用户自定义函数、存储函数、用户变量、临时表、mysql库中的系统表，或者任何包含列级别权限的表，都不会被缓存

查询缓存系统会跟踪查询中涉及的每个表，如果这些表发生变化，那么和这个表相关的所有的缓存数据都将失效

MySQL如何判断缓存命中
缓存存放在一个引用表中，通过一个哈希值引用，这个哈希值包括了如下因素，即查询本身、当前要查询的数据库、客户端协议的版本等一些其他可能会影响返回结果的信息。当判断缓存是否命中时，MySQL不会解析、“正规化”或者参数化查询语句，而是直接使用SQL语句和客户端发送过来的其他原始信息。任何字符上的不同，例如空格、注释等，任何的不同都会导致缓存的不命中。

打开查询缓存的额外消耗
1、读查询在开始之前必须先检查是否命中缓存。
2、如果这个读查询可以被缓存，那么当完成执行后，MySQL若发现查询缓存中没有这个查询，会将其结果存入查询缓存
3、当向某个表写入数据的时候，MySQL必须将对应表的所有缓存都设置失效。如果查询缓存非常大或者碎片很多，这个操作就可能会带来很大系统消耗

缓存未命中的原因
1、查询语句无法被缓存，可能是因为查询中包含一个不确定的函数，或者查询结果太大而无法缓存。
2、MySQL从未处理这个查询，所以结果也从不曾被缓存过。
3、虽然之前缓存了查询结果，但是由于查询缓存的内存用完了，MySQL需要将某些缓存“逐出”，或者由于数据表被修改导致缓存失效。

查询大多已缓存但仍大量未命中的原因
1、查询缓存还没有完成预热。也就是说，MySQL还没有机会将查询结果都缓存起来。
2、查询语句之前从未执行过。如果你的应用程序不会重复执行一条查询语句，那么即使完成预热仍然会有很多缓存未命中。
3、缓存失效操作太多了。

配置和维护查询缓存
query_cache_type：是否打开查询缓存（OFF、ON或DEMAND）。DEMAND表示查询语句明确写明SQL_CACHE的语句才放入查询缓存。这个变量可以是会话级别也可以是全局级别
query_cache_size：查询缓存使用的总内存空间，单位是字节，值必须是1024的整数倍
query_cache_min_res_unit：在查询缓存中分配内存块时的最小单位
query_cache_limit：MySQL能够缓存的最大查询结果。如果查询结果大于这个值，则不会被缓存
query_cache_wlock_invalidate：如果某个数据表被其他的连接锁住，是否仍然从查询缓存中返回结果。默认是OFF，这可能在一定程序上会改变服务器的行为，因为这使得数据库可能返回其他线程锁住的数据。将参数设置成ON，则不会从缓存中读取这类数据，但是这可能会增加锁等待</code></pre>

<p>&nbsp;</p>
				    </section>
					</article>
				</main>
            </div>
        </div>
    </section>
    <a href="#top" id="goTop" ><i class="fa fa-angle-up fa-3x"></i></a>
	<script src="../js/jquery.min.js"></script>
    <script type="text/javascript" src="../js/datas/detailAngularJs.js"></script>
    <script src="../plugins/scrolltopcontrol.js"></script>
</body>
</html>